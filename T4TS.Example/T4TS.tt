<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ output extension=".d.ts" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="$(SolutionDir)\\T4TS\\bin\\Debug\\T4TS.Dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="T4TS" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ Include File="T4TS.tt.settings.t4" #>
<#= 
    T4TS.OutputFormatter.GetOutput(GetDataToRender(), ReadSettings()) #><#+ 

List<TypeScriptModule> GetDataToRender() {
    DTE dte = null;

    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null)
        dte = serviceProvider.GetService(typeof(SDTE)) as DTE;

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (dte == null)
        throw new Exception("Can only execute through the Visual Studio host");

    var project = GetProjectContainingT4File(dte);
        
    if (project == null)
        throw new Exception("Could not find the VS project containing the T4TS file.");

    var generator = new CodeTraverser(project, ReadSettings());
    return generator.GetAllInterfaces().ToList();
}

Settings ReadSettings()
{
    // Read settings from T4TS.tt.settings.tt
    return new Settings
    {
        DefaultModule = ParseSettingReferenceType("DefaultModule", s => s as string, "T4TS"),
        DefaultOptional = ParseSettingNullableType("DefaultOptional", false),
        DefaultCamelCaseMemberNames = ParseSettingNullableType("DefaultCamelCaseMemberNames", false),
        DefaultInterfaceNamePrefix = ParseSettingReferenceType("DefaultInterfaceNamePrefix", s => s as string, string.Empty),
        CompatibilityVersion = ParseSettingReferenceType("CompatibilityVersion", v => v as Version, new Version(0,9,1,1))
    };
}

T ParseSettingReferenceType<T>(string key, Func<object, T> convert, T defaultValue) where T:class
{
    object val;
    if (SettingsValues.TryGetValue(key, out val))
        return convert(val) ?? defaultValue;

    return defaultValue;
}

T ParseSettingNullableType<T>(string key, T defaultValue) where T: struct
{
    object val;
    if (SettingsValues.TryGetValue(key, out val))
    {
        var nullable = val as Nullable<T>;
        if (nullable == null || !nullable.HasValue)
            return defaultValue;

        return nullable.Value;
    }

    return defaultValue;
}

T ParseConfigValueType<T>(string key, Func<object, T> convert, T defaultValue)
{
    object val;
    if (SettingsValues.TryGetValue(key, out val))
        return convert(val);

    return defaultValue;
}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
    // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
    // Note: this is certainly hacky, but is the best I could come up with so far.
    projectItem.Document.Saved = false;

    return projectItem.ContainingProject;
}
#>
