<#@ template language="C#" debug="true" hostspecific="true" 
#><#@ output extension=".cs" 
#><#@ assembly name="System.Core" 
#><#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" 
#><#@ assembly name="EnvDTE" 
#><#@ assembly name="EnvDTE80" 
#><#@ assembly name="VSLangProj" 
#><#@ assembly name="System.Xml" 
#><#@ assembly name="System.Xml.Linq" 
#><#@ import namespace="System.Collections.Generic" 
#><#@ import namespace="System.IO" 
#><#@ import namespace="System.Linq" 
#><#@ import namespace="System.Text" 
#><#@ import namespace="System.Text.RegularExpressions" 
#><#@ import namespace="Microsoft.VisualStudio.Shell.Interop" 
#><#@ import namespace="EnvDTE" 
#><#@ import namespace="EnvDTE80" 
#><#@ import namespace="Microsoft.VisualStudio.TextTemplating" 
#><# PrepareDataToRender(this); var manager = Manager.Create(Host, GenerationEnvironment); manager.StartNewFile("T4TS.d.ts"); #>
/************************************************
  Generated by T4TS
  Changes made in this file will be overwritten.
************************************************/

module Api {

<# foreach(var tsInterface in output) { #>
    /** Generated from <#= tsInterface.FullName #> **/
    export interface <#= tsInterface.Name #> {
<# foreach(var member in tsInterface.Members) { #>
        <#= member.Name #>: <#=member.Type #>;
<# } #>
<# if (tsInterface.IndexerType != null) { #>
        [index: number]: <#= tsInterface.IndexerType #>;
<# } #>
    }

<# } #>
}
<#manager.EndBlock(); 
#>
namespace T4TS
{
    using System;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    
    [GeneratedCode("T4TS", "0.1")]
    public class TypeScriptInterfaceAttribute : Attribute
    {
        public TypeScriptInterfaceAttribute()
        {
        }
    }
}
<#manager.Process(true); #><#+ 

static DTE Dte;
static Project Project;
static TextTransformation TT;
static string attributeFullName = "T4TS.TypeScriptInterfaceAttribute";
static List<TypeScriptInterface> output;

void PrepareDataToRender(TextTransformation tt) {
    TT = tt;

    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null) {
        Dte = serviceProvider.GetService(typeof(SDTE)) as DTE;
    }

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (Dte == null) {
        throw new Exception("Can only execute through the Visual Studio host");
    }

    Project = GetProjectContainingT4File(Dte);
	
    if (Project == null) {
        Error("Could not find the VS Project containing the T4TS file.");
        return;
    }

	var generator = new CodeGenerator(Project);

	output = generator.GetInterfaces().ToList();
}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
    // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
    // Note: this is certainly hacky, but is the best I could come up with so far.
    projectItem.Document.Saved = false;

    return projectItem.ContainingProject;
}

public class CodeGenerator
{
    public Project Project { get; private set; }
    private static readonly string AttributeFullName = "T4TS.TypeScriptInterfaceAttribute";

    private static readonly string[] genericCollectionTypeStarts = new string[] {
        "System.Collections.Generic.List<",
        "System.Collections.Generic.IList<",
        "System.Collections.Generic.ICollection<"
    };

    public CodeGenerator(Project project)
    {

        this.Project = project;
    }

    public IEnumerable<TypeScriptInterface> GetInterfaces()
    {
        // A context that holds all interfaces that will be generated.
        // Keyed on the FullName of the CodeType.
        var typeContext = new TypeContext(VisitProjectItems(Project.ProjectItems)
            .ToDictionary(i => i.CodeType.FullName, i => i));

        foreach (var instance in typeContext.Values)
            yield return GetInterface(instance, typeContext);
    }

    private IEnumerable<AttributeDecoratedInstance> VisitProjectItems(ProjectItems items)
    {
        foreach (ProjectItem pi in items)
        {
            if (pi.FileCodeModel != null)
            {
                var codeElements = pi.FileCodeModel.CodeElements;
                foreach (CodeElement codeElement in codeElements)
                {
                    if (codeElement is CodeNamespace)
                    {
                        foreach (var instance in FindClassesWithAttribute(codeElement as CodeNamespace))
                            yield return instance;
                    }
                }
            }

            if (pi.ProjectItems != null && pi.ProjectItems.Count > 0)
            {
                foreach (var tsInterface in VisitProjectItems(pi.ProjectItems))
                    yield return tsInterface;
            }
        }
    }

    private IEnumerable<AttributeDecoratedInstance> FindClassesWithAttribute(CodeNamespace ns)
    {
        foreach (CodeElement codeElement in ns.Members)
        {
            if (codeElement is CodeType)
            {
                var ct = codeElement as CodeType;
                if (ct.Attributes == null)
                    continue;

                foreach (CodeAttribute attr in ct.Attributes)
                {
                    if (attr.FullName == AttributeFullName)
                    {
                        yield return new AttributeDecoratedInstance
                        {
                            CodeType = ct,
                            Namespace = ns,
                            TypescriptType = ct.Name
                        };

                        break;
                    }
                }
            }
        }
    }

    private TypeScriptInterface GetInterface(AttributeDecoratedInstance instance, TypeContext typeContext)
    {
        var tsInterface = new TypeScriptInterface
        {
            FullName = instance.CodeType.FullName,
            Name = instance.CodeType.Name,
            Members = GetMembers(instance, typeContext).ToList()
        };

        if (instance.CodeType.Bases.Count > 0)
        {
            foreach (CodeElement elem in instance.CodeType.Bases)
            {
                if (genericCollectionTypeStarts.Any(elem.FullName.StartsWith))
                {
                    string fullName = UnwrapGenericType(elem.FullName);
                    if (typeContext.ContainsKey(fullName))
                    {
                        tsInterface.IndexerType = typeContext[fullName].CodeType.Name;
                        return tsInterface;
                    }
                }
            }
        }

        return tsInterface;
    }

    private IEnumerable<TypeScriptInterfaceMember> GetMembers(AttributeDecoratedInstance instance, TypeContext typeContext)
    {
        foreach (CodeElement codeElement in instance.CodeType.Members)
        {
            if (!(codeElement is CodeProperty))
                continue;

            var codeProperty = (CodeProperty)codeElement;
            if (codeProperty.Access != vsCMAccess.vsCMAccessPublic)
                continue;

            var func = codeProperty.Getter;
            if (func != null)
            {
                yield return new TypeScriptInterfaceMember
                {
                    Name = codeProperty.Name,
                    Type = GetTypeScriptType(instance, func.Type, codeProperty, typeContext)
                };
            }
        }
    }

    private string GetTypeScriptType(AttributeDecoratedInstance instance, CodeTypeRef codeType, CodeProperty codeProperty, TypeContext typeContext)
    {
        switch (codeType.TypeKind)
        {
            case vsCMTypeRef.vsCMTypeRefChar:
            case vsCMTypeRef.vsCMTypeRefString:
                return "string";

            case vsCMTypeRef.vsCMTypeRefBool:
                return "bool";

            case vsCMTypeRef.vsCMTypeRefByte:
            case vsCMTypeRef.vsCMTypeRefDouble:
            case vsCMTypeRef.vsCMTypeRefInt:
            case vsCMTypeRef.vsCMTypeRefShort:
            case vsCMTypeRef.vsCMTypeRefFloat:
            case vsCMTypeRef.vsCMTypeRefLong:
            case vsCMTypeRef.vsCMTypeRefDecimal:
                return "number";

            default:
                return TryResolveType(instance, codeType, codeProperty, typeContext);
        }
    }

    private string TryResolveType(AttributeDecoratedInstance instance, CodeTypeRef codeType, CodeProperty codeProperty, TypeContext typeContext)
    {
        if (codeType.TypeKind == vsCMTypeRef.vsCMTypeRefArray)
        {
            string typeFullName = codeType.ElementType.AsFullName;
            return TryResolveEnumerableType(typeFullName, typeContext);
        }

        if (genericCollectionTypeStarts.Any(s => codeType.AsFullName.StartsWith(s)))
        {
            string fullName = UnwrapGenericType(codeType);
            return TryResolveEnumerableType(fullName, typeContext);
        }

        return TryResolveUnknownType(codeType.AsFullName, typeContext);
    }

    private string TryResolveEnumerableType(string typeFullName, TypeContext typeContext)
    {
        return TryResolveUnknownType(typeFullName, typeContext) + "[]";
    }

    private string TryResolveUnknownType(string typeFullName, TypeContext typeContext)
    {
        AttributeDecoratedInstance instance;
        if (typeContext.TryGetValue(typeFullName, out instance))
            return instance.CodeType.Name;

        switch (typeFullName)
        {
            case "System.Double":
            case "System.Int16":
            case "System.Int32":
            case "System.Int64":
            case "System.UInt16":
            case "System.UInt32":
            case "System.UInt64":
            case "System.Decimal":
            case "System.Byte":
            case "System.SByte":
            case "System.Single":
                return "number";

            case "System.String":
            case "System.DateTime":
                return "string";
                
            case "System.Object":
                return "Object";

            default:
                return "any";
        }
    }

    private string UnwrapGenericType(CodeTypeRef codeType)
    {
        return UnwrapGenericType(codeType.AsFullName);
    }

    private string UnwrapGenericType(string typeFullName)
    {
        return typeFullName.Split('<', '>')[1];
    }
}

public class TypeContext: Dictionary<string, AttributeDecoratedInstance>
{
    public TypeContext(IDictionary<string, AttributeDecoratedInstance> dictionary): base(dictionary)
    {

    }
}
    
public class TypeScriptInterface
{
    public string Name { get; set; }
    public string FullName { get; set; }
    public List<TypeScriptInterfaceMember> Members { get; set; }
    public string IndexerType { get; set; }
}
    
public class AttributeDecoratedInstance
{
    public CodeNamespace Namespace { get; set; }
    public CodeType CodeType { get; set; }
    public string TypescriptType { get; set; }
}

public class TypeScriptInterfaceMember
{
    public string Name { get; set; }
    public string Type { get; set; }
}


// -------------------------------------------------------------------------------
// https://raw.github.com/damieng/DamienGKit
// http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
// -------------------------------------------------------------------------------

// Manager class records the various blocks so it can split them up
class Manager {
    private class Block {
        public String Name;
        public int Start, Length;
    }

    private Block currentBlock;
    private List<Block> files = new List<Block>();
    private Block footer = new Block();
    private Block header = new Block();
    private ITextTemplatingEngineHost host;
    private StringBuilder template;
    protected List<String> generatedFileNames = new List<String>();

    public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template) {
        return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
    }

    public void StartNewFile(String name) {
        if (name == null)
            throw new ArgumentNullException("name");
        CurrentBlock = new Block { Name = name };
    }

    public void StartFooter() {
        CurrentBlock = footer;
    }

    public void StartHeader() {
        CurrentBlock = header;
    }

    public void EndBlock() {
        if (CurrentBlock == null)
            return;
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if (CurrentBlock != header && CurrentBlock != footer)
            files.Add(CurrentBlock);
        currentBlock = null;
    }

    public virtual void Process(bool split, bool sync = true) {
        if (split) {
            EndBlock();
            String headerText = template.ToString(header.Start, header.Length);
            String footerText = template.ToString(footer.Start, footer.Length);
            String outputPath = Path.GetDirectoryName(host.TemplateFile);
            files.Reverse();
            foreach(Block block in files) {
                String fileName = Path.Combine(outputPath, block.Name);
                String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                generatedFileNames.Add(fileName);
                CreateFile(fileName, content);
                template.Remove(block.Start, block.Length);
            }
        }
    }

    protected virtual void CreateFile(String fileName, String content) {
        if (IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }

    public virtual String GetCustomToolNamespace(String fileName) {
        return null;
    }

    public virtual String DefaultProjectNamespace {
        get { return null; }
    }

    protected bool IsFileContentDifferent(String fileName, String newContent) {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    private Manager(ITextTemplatingEngineHost host, StringBuilder template) {
        this.host = host;
        this.template = template;
    }

    private Block CurrentBlock {
        get { return currentBlock; }
        set {
            if (CurrentBlock != null)
                EndBlock();
            if (value != null)
                value.Start = template.Length;
            currentBlock = value;
        }
    }

    private class VSManager: Manager {
        private EnvDTE.ProjectItem templateProjectItem;
        private EnvDTE.DTE dte;
        private Action<String> checkOutAction;
        private Action<IEnumerable<String>> projectSyncAction;

        public override String DefaultProjectNamespace {
            get {
                return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
            }
        }

        public override String GetCustomToolNamespace(string fileName) {
            return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
        }

        public override void Process(bool split, bool sync) {
            if (templateProjectItem.ProjectItems == null)
                return;
            base.Process(split, sync);
            if (sync)
                projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
        }

        protected override void CreateFile(String fileName, String content) {
            if (IsFileContentDifferent(fileName, content)) {
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }

        internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template) {
            var hostServiceProvider = (IServiceProvider) host;
            if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
            if (dte == null)
                throw new ArgumentNullException("Could not obtain DTE from host");
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
        }

        private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames) {
            var keepFileNameSet = new HashSet<String>(keepFileNames);
            var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
            var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
            foreach(EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                projectFiles.Add(projectItem.get_FileNames(0), projectItem);

            // Remove unused items from the project
            foreach(var pair in projectFiles)
                if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                    pair.Value.Delete();

            // Add missing files to the project
            foreach(String fileName in keepFileNameSet)
                if (!projectFiles.ContainsKey(fileName))
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
        }

        private void CheckoutFileIfRequired(String fileName) {
            var sc = dte.SourceControl;
            if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
                checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
        }
    }
}
#>